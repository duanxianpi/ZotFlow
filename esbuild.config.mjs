import esbuild from "esbuild";
import process from "process";
import fs, { watch } from "fs";
import path from "path";
import zlib from "zlib";
import { glob } from "glob";
import { builtinModules } from "node:module";

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/`;

const prod = process.argv[2] === "production";

/**
 * Custom plugin: Inline worker code
 * Compiles the worker to a string and exports it
 */
const inlineWorkerPlugin = {
    name: "inline-worker-plugin",
    setup(build) {
        build.onResolve({ filter: /^virtual:worker$/ }, (args) => {
            return { path: args.path, namespace: "worker-code" };
        });

        build.onLoad({ filter: /.*/, namespace: "worker-code" }, async () => {
            const workerEntry = path.resolve("src/worker/worker.ts");
            const files = await glob("**/*", {
                cwd: "src/worker",
                nodir: true,
            });
            const absoluteWatchFiles = files.map((file) =>
                path.join("src/worker", file),
            );
            // Build the worker specifically
            const result = await esbuild.build({
                entryPoints: [workerEntry],
                bundle: true,
                write: false,
                format: "iife",
                target: "es2018",
                minify: prod,
                plugins: [], // No plugins for the worker itself to avoid recursion if not needed
                external: ["obsidian"],
            });

            const workerCode = result.outputFiles[0].text;
            // Escape backticks and other special chars if necessary, but JSON.stringify is safest for a string literal

            return {
                contents: `export default ${JSON.stringify(workerCode)};`,
                loader: "js",
                watchFiles: absoluteWatchFiles,
            };
        });
    },
};

/**
 * Custom plugin: Inline resources
 * When import "virtual:reader-resources", it will return a function that can be used to load resources.
 */
const inlineResourcePlugin = {
    name: "inline-resource-plugin",
    setup(build) {
        build.onResolve({ filter: /^virtual:reader-resources$/ }, (args) => {
            return { path: args.path, namespace: "reader-resources" };
        });

        build.onLoad(
            { filter: /.*/, namespace: "reader-resources" },
            async () => {
                const resourceDir = path.resolve(
                    "reader/reader/build/obsidian",
                );
                const files = await glob("**/*", {
                    cwd: resourceDir,
                    nodir: true,
                });
                const absoluteWatchFiles = files.map((file) =>
                    path.join(resourceDir, file),
                );
                // Generate keys array
                const keys = files.map((f) => "./" + f.replace(/\\/g, "/"));

                // Generate Switch Case code block (Lazy Load)
                let switchCases = "";

                files.forEach((file) => {
                    const filePath = path.join(resourceDir, file);
                    const content = fs.readFileSync(filePath);

                    // Compress & Base64
                    const gzipped = zlib.gzipSync(content);
                    const base64 = gzipped.toString("base64");

                    const key = "./" + file.replace(/\\/g, "/");

                    switchCases += `    case "${key}": return "${base64}";\n`;
                });

                const contents = `
        export function resourceKeys() {
          return ${JSON.stringify(keys)};
        }
        
        export default function(key) {
          switch(key) {
${switchCases}
            default: return undefined;
          }
        }
      `;

                return {
                    contents,
                    loader: "js",
                    resolveDir: resourceDir,
                    watchFiles: absoluteWatchFiles,
                    watchDirs: [resourceDir],
                };
            },
        );
    },
};

/**
 * Custom plugin: Copy the reader/reader/build/obsidian/reader.js.LICENSE.txt to the output directory.
 */
const copyLicensePlugin = {
    name: "copy-license-plugin",
    setup(build) {
        build.onEnd(() => {
            try {
                const licenseFile = path.resolve(
                    "reader/reader/build/obsidian/reader.js.LICENSE.txt",
                );
                const licenseContent = fs.readFileSync(licenseFile, "utf-8");
                fs.writeFileSync("reader.js.LICENSE.txt", licenseContent);
            } catch (e) {}
        });
    },
};

const context = await esbuild.context({
    banner: {
        js: banner,
    },
    entryPoints: ["src/main.ts"],
    bundle: true,
    external: [
        "obsidian",
        "electron",
        "@codemirror/autocomplete",
        "@codemirror/collab",
        "@codemirror/commands",
        "@codemirror/language",
        "@codemirror/lint",
        "@codemirror/search",
        "@codemirror/state",
        "@codemirror/view",
        "@lezer/common",
        "@lezer/highlight",
        "@lezer/lr",
        ...builtinModules,
    ],
    format: "cjs",
    target: "es2018",
    logLevel: "info",
    platform: "browser",
    sourcemap: prod ? false : "inline",
    treeShaking: true,
    outfile: "main.js",
    minify: prod,
    plugins: [inlineResourcePlugin, copyLicensePlugin, inlineWorkerPlugin],
});

if (prod) {
    await context.rebuild();
    process.exit(0);
} else {
    await context.watch();
}
